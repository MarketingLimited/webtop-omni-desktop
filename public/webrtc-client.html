<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Desktop Audio</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a202c;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: #2d3748;
            border-radius: 12px;
        }
        button {
            padding: 12px 24px;
            background: #4299e1;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover {
            background: #3182ce;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #718096;
            cursor: not-allowed;
            transform: none;
        }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #4a5568;
            outline: none;
            cursor: pointer;
        }
        .status {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
        }
        .status.connected {
            background: rgba(56, 161, 105, 0.2);
            border: 1px solid #38a169;
            color: #68d391;
        }
        .status.disconnected {
            background: rgba(229, 62, 62, 0.2);
            border: 1px solid #e53e3e;
            color: #fc8181;
        }
        .status.connecting {
            background: rgba(66, 153, 225, 0.2);
            border: 1px solid #4299e1;
            color: #90cdf4;
        }
        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .quality-bar {
            width: 100px;
            height: 6px;
            background: #4a5568;
            border-radius: 3px;
            overflow: hidden;
        }
        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #e53e3e, #f6ad55, #68d391);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽµ WebRTC Desktop Audio</h1>
        
        <div class="audio-controls">
            <button id="connectBtn">Connect Audio</button>
            <button id="disconnectBtn" disabled>Disconnect</button>
            
            <div class="volume-control">
                <label>Volume:</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="50">
                <span id="volumeLabel">50%</span>
            </div>
        </div>
        
        <div id="status" class="status disconnected">Disconnected</div>
        
        <div class="quality-indicator">
            <span>Quality:</span>
            <div class="quality-bar">
                <div id="qualityFill" class="quality-fill"></div>
            </div>
            <span id="qualityText">-</span>
        </div>
        
        <audio id="audioElement" autoplay controls style="width: 100%; margin-top: 20px;"></audio>
    </div>
    
    <script>
        class WebRTCAudioStreamer {
            constructor() {
                this.peerConnection = null;
                this.websocket = null;
                this.isConnected = false;
                this.audioElement = document.getElementById('audioElement');
                
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.volumeLabel = document.getElementById('volumeLabel');
                this.status = document.getElementById('status');
                this.qualityFill = document.getElementById('qualityFill');
                this.qualityText = document.getElementById('qualityText');
                
                this.setupEventListeners();
                this.setupQualityMonitoring();
                this.trackTimeout = null;
            }
            
            setupEventListeners() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.volumeSlider.addEventListener('input', (e) => this.setVolume(e.target.value));
            }
            
            async connect() {
                try {
                    this.updateStatus('Connecting...', 'connecting');
                    
                    // Create peer connection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    });
                    
                    // Handle incoming audio stream
                    this.peerConnection.ontrack = (event) => {
                        console.log('ðŸ“¡ Received audio track');
                        clearTimeout(this.trackTimeout);
                        this.audioElement.srcObject = event.streams[0];
                        this.setVolume(this.volumeSlider.value);
                    };
                    
                    // Handle connection state changes
                    this.peerConnection.oniceconnectionstatechange = () => {
                        console.log('ðŸ”— ICE connection state:', this.peerConnection.iceConnectionState);
                        if (this.peerConnection.iceConnectionState === 'connected') {
                            this.isConnected = true;
                            this.updateUI();
                            this.updateStatus('Audio connected via WebRTC', 'connected');
                        } else if (this.peerConnection.iceConnectionState === 'disconnected' || 
                                   this.peerConnection.iceConnectionState === 'failed') {
                            this.disconnect();
                        }
                    };
                    
                    // Connect to signaling server
                    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    this.websocket = new WebSocket(`${wsProtocol}//${window.location.hostname}:8081`);
                    
                    this.websocket.onopen = async () => {
                        console.log('ðŸ”Œ Connected to signaling server');
                        
                        // Create offer
                        const offer = await this.peerConnection.createOffer();
                        await this.peerConnection.setLocalDescription(offer);
                        
                        this.websocket.send(JSON.stringify({
                            type: 'offer',
                            offer: offer
                        }));

                        // If the backend fails to supply audio within a few seconds,
                        // display a helpful error message for the user.
                        this.trackTimeout = setTimeout(() => {
                            if (!this.audioElement.srcObject) {
                                this.updateStatus('No audio received from server', 'disconnected');
                                this.disconnect();
                            }
                        }, 5000);
                    };

                    this.websocket.onerror = (err) => {
                        console.error('WebSocket error:', err);
                        this.updateStatus('Signaling connection error', 'disconnected');
                        this.disconnect();
                    };
                    
                    this.websocket.onmessage = async (event) => {
                        const data = JSON.parse(event.data);
                        
                        switch (data.type) {
                            case 'answer':
                                await this.peerConnection.setRemoteDescription(data.answer);
                                break;
                            case 'ice-candidate':
                                await this.peerConnection.addIceCandidate(data.candidate);
                                break;
                        }
                    };
                    
                    // Send ICE candidates
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.websocket.readyState === WebSocket.OPEN) {
                            this.websocket.send(JSON.stringify({
                                type: 'ice-candidate',
                                candidate: event.candidate
                            }));
                        }
                    };
                    
                } catch (error) {
                    console.error('âŒ Connection failed:', error);
                    this.updateStatus('Connection failed: ' + error.message, 'disconnected');
                }
            }
            
            disconnect() {
                if (this.trackTimeout) {
                    clearTimeout(this.trackTimeout);
                    this.trackTimeout = null;
                }

                if (this.websocket) {
                    this.websocket.send(JSON.stringify({ type: 'close' }));
                    this.websocket.close();
                    this.websocket = null;
                }
                
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                
                if (this.audioElement.srcObject) {
                    this.audioElement.srcObject.getTracks().forEach(track => track.stop());
                    this.audioElement.srcObject = null;
                }
                
                this.isConnected = false;
                this.updateUI();
                this.updateStatus('Disconnected', 'disconnected');
            }
            
            setVolume(value) {
                this.audioElement.volume = value / 100;
                this.volumeLabel.textContent = value + '%';
                localStorage.setItem('webrtc-audio-volume', value);
            }
            
            updateUI() {
                this.connectBtn.disabled = this.isConnected;
                this.disconnectBtn.disabled = !this.isConnected;
            }
            
            updateStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
            }
            
            setupQualityMonitoring() {
                setInterval(() => {
                    if (this.peerConnection && this.isConnected) {
                        this.peerConnection.getStats().then(stats => {
                            let quality = 0;
                            stats.forEach(report => {
                                if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                                    const packetsLost = report.packetsLost || 0;
                                    const packetsReceived = report.packetsReceived || 0;
                                    const total = packetsLost + packetsReceived;
                                    quality = total > 0 ? ((packetsReceived / total) * 100) : 0;
                                }
                            });
                            
                            this.qualityFill.style.width = quality + '%';
                            this.qualityText.textContent = Math.round(quality) + '%';
                        });
                    } else {
                        this.qualityFill.style.width = '0%';
                        this.qualityText.textContent = '-';
                    }
                }, 2000);
            }
        }
        
        // Initialize audio streamer when page loads
        window.addEventListener('load', () => {
            new WebRTCAudioStreamer();
        });
    </script>
</body>
</html>
